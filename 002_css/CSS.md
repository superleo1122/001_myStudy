# 一、CSS

## 1.文字属性
1. 规定文字样式
    1. font-style
        1. normal 正常的
        2. italic 倾斜的

2. 规定文字粗细
    1. font-weight
        1. bold 加粗
        2. bolder 比加粗还要粗
        3. lighter 细线，默认
        4. 100

3. 规定文字大小
    1. font-size
    
4. 规定文字字体
    1. font-family
        1. 字体名  中文一定要用双引号或者单引号
        2. 字体名，字体名    
    注意：中文字体都可以处理英文，英文字体不能处理中文，所以要想让英文和中文显示不同字体，需要将英文字体放前面，中文字体放后面。

5. 简写格式
    + font: style weight size family;
    + style和weight可以省略，但size和family不可省略。style和weight位置可以交换，size和family不可互换。

## 2. 文本属性
1. 文本装饰属性
    1. text-decoration
        1. underline 下划线
        2. line-through 删除线
        3. overline 上划线
        4. none 什么都没有，最常见用途为去掉超链接的下划线

2. 文本缩进的属性
   + text-indent
3. 2em em是单位，一个em代表缩进一个文字的宽度
4. vertical-align 重点
   + baseline
   + top
   + middle
   + bottom
   + text-top
   + text-bottom
   + 注意点
     + text-align是设置给父元素的，而vertical-align是设置给需要垂直对齐的那个元素本身的
     + vertical-align只对内联元素有效
     + 图片默认是跟一行文字的基线对齐的，基线就是一行文字中最短那个文字的底部

## 3. 颜色属性
1. color
    1. red  英文单词
    2. rgb(255,0,0)  rgb
    2. rgba(255,0,0,0.1)  rgba  a代表透明度，为0到1
    3. `#FF0000`  十六进制
    4. `#F00`    十六进制缩写

## 4. 选择器
1. 元素选择器
   
   + `p{}` 
   
2. id选择器

   + `#id{}` 在前端开发中，如果仅仅是为了设置样式，不会使用id，id是留给js使用的

3. 类选择器

   + `.class{}` 每个标签可以绑定多个类名，class="class1 class2..."

4. 后代选择器

   + `div p{} 上面以上三种选择器随意组合，可以不止两层` 所有后代都会被选择

5. 子元素选择器

   + `标签名称1>标签名称2{}  组合层数同上` 找到指定标签中特定的直接子元素，不能找到孙子及以下

6. 交集选择器

   + `选择器1选择器2{}` 给所有选择器选中的标签中，相交的那部分标签设置属性，实际应用不多

7. 并集选择器

   + `选择器1,选择器2{}` 用逗号连接

8. 兄弟选择器

   1. 相邻兄弟选择器 css2
      + `选择器1+选择器2{}` 给指定选择器后面紧跟的那个选择器中的标签设置属性

   2. 通过选择器 css3
      + `选择器1波浪线选择器2{}` 给指定选择器后面的所有选择器中的所有标签设置属性

9. 序选择器

   + 1.同级别的第几个

     `标签名:first-child{}` 选中同级别的第一个标签，不区分类型 <br>
     `标签名:last-child{}` 选中同级别的最后一个标签，不区分类型 <br>
     `标签名:nth-child(x)` 选择同级别的第x个标签 <br>
     `标签名:nth-last-child(x)` 选择同级别的倒数第x个标签 <br>
     `标签名:only-child` 选中父元素中唯一的元素 <br>
     `标签名:nth-child(odd)` 选中同级别中的所有奇数 <br>
     `标签名:nth-child(even)` 选中同级别中的所有偶数 <br>
     `标签名:nth-child(xn+y)`

   + 2.同类型的第几个

     `标签名:first-of-type{}` 选中同级别同类型的第一个标签 <br>
     `标签名:last-of-type{}` 选择同级别同类型的最后一个标签 <br>
     `标签名:nth-of-type(x)`选择同级别同类型的第x个标签 <br>
     `标签名:nth-last-of-type(x)`选择同级别同类型的倒数第x个标签 <br>
     `标签名:only-of-type` 选中父元素中同类型的唯一标签 <br>
     `标签名:nth-of-type(odd)` 选择同级别同类型的所有奇数 <br>
     `标签名:nth-of-type(even)` 选择同级别同类型的所有偶数 <br>
     `标签名:nth-of-type(xn+y)`

10. 属性选择器

    + 简单
      + [attr]
      + [attr=value] 最常见场景用户区分input标签

    + 复杂

      + 属性的取值是以什么开头的
        1. [attr|=value] css2  弃用
        2. [attr^=value] css3
        3. css2中的智能找到value开头，并且value是被-和其他内容隔开的
        4. css3中的主要是以value开头的都可以找到，无论有没有被-隔开

      + 属性的取值是以什么结尾的
        1. [attr$=value] css3

      + 属性的取值是否包含某个特定的值

        1. [attr上波浪线=value] css2  弃用

        2. [attr*=value] css3

        3. css2中的智能找到value开头，并且value是被空格和其他内容隔开的

        4. css3中的主要是以value开头的都可以找到，无论有没有被空格隔开

11. 通配符选择器

    + `*{}`

## 5.  三大特性

1. 同一个标签，背景颜色和背景图片可以同时存在

2. css精灵图是一种图片合成技术，将多张图片合成一张图片

3. text-align 使盒子中的文字、图片水平居中

4. div可以被行高撑起

5. 文字在行高中垂直居中

6. 继承性

   + 给父元素设置一些属性，子元素也可以使用

   + 并不是所有的属性都可以继承，只有以color/font-/text-/line开头的属性才可以继承

   +　在css的继承中不仅是儿子可以继承，只要是后代都可以继承

   + 继承性中的特殊性:

     + a标签的文字颜色和下划线不能继承

     + h标签的文字大小不能继承

7. 层叠性

   + 层叠性只有在多个选择器选中"同一个标签"，然后设置了"相同的属性"，才会发生层叠性。

8. 优先级

   + 如何层叠由优先级判断。优先级判断的三种方式

     1. 是否是直接选中(间接选中就是指继承)  
        + 就近原则

     2. 是否是相同的选择器
        + 末尾原则 

     3. 不同选择器(如果都是直接选中且不同类型的选择器)
        + id>类>元素>通配符>继承>浏览器默认

9. important 
   + 用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级提升为最高
   + 用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级提升为最高
   + 只能用于直接选中，不能用于间接选中。(即给父元素的某个属性提升优先级，其子元素的优先级不会起作用，除非直接作用在子元素的属性上)
   + 只能提升标记的属性。

10. 优先级权重

  + 当多个选择器混合在一起使用时，我们可以通过计算权重来判断谁的优先级最高。权重的计算规则如下：

    + 首先计算选择器中有多少个id，id多的优先级最高

    + 若id数量一致，则看类名个数，类名个数多的优先级最高

    + 若类名个数一致，则看标签名个数，标签名个数多的优先级最高

    + 若id个数一样，类名个数一样，标签名个数一样，则末尾原则
    + 只有直接选中才会计算权重

11. 优先级判断方法

  + 先判断是否是直接选中，然后判断是否有id选择器，是否有类选择器，是否元素个数多，末尾原则     

## 6. div&span
1. div
   + div一般配置css完成网页的基本布局
2. span
   + span一般用于配合css修改网页中的一些局部信息
3. div和span区别
    1. div独占一行，而span不是 
    2. div是容器级别的标签，span是文本级别的标签
        + 容器级别的标签可以嵌套其他所有的标签
        + 文本级的标签只能嵌套文字/超链接/图片


## 7. CSS元素的显示模式    
1. 标签分类
    + 在HTML中将所有的标签分为两类，分别是容器级和文本级
    + 在CSS中将所有标签分为两类，分别是块级元素和行内元素(其实可以分为三类:块级、行内、行内块级)

2. 两种分类的联系
    + 所有的容器级元素都是块级元素，文本级元素除了p标签外都是行内元素，p标签是块级元素。

3. 块级元素和行内元素区别
    1. 块级元素
        + 独占一行
        + 若不设置宽度，默认和父元素一样宽
        + 若设置宽度，则按设置宽度显示
    2. 行内元素
        + 不独占一行
        + 不可以设置宽度和高度，默认和内容一样宽
    3. 行内块级元素
        + 不独占一行
        + 可以设置宽度和高度          

4. 显示模式转换
    + display
        + 行内  display:inline
        + 块级  display:block
        + 行内块级  display:inline-block

## 8. 背景
1. 设置背景图片
    1. background-image:url()  图片大小没有标签大，会水平和垂直方向平铺
    2. background-repeat
        1. repeat  默认，在水平和垂直方向平铺
        2. no-repeat  在水平和垂直方向都不平铺
        3. repeat-x  在水平方向上平铺
        4. repeat-y  在垂直方向上平铺
        + 在实际应用中可以使用repeat属性使得小图变大图，降低数据大小
    3. background-position 背景图片位置
        1. 具体的方位名词
            1. 水平方向：left center right
            2. 垂直方向：top bottom center
        2. 具体的像素     
            100px,200px  具体的像素可以接收负数
    4. background-attachment 关联方式
        1. scroll 默认值，会随着滚动条的滚动而滚动
        2. fixed  不会随着滚动条的滚动而滚动
    
2. 背景属性缩写
    + background:背景颜色 背景图片 平铺方式 关联方式 定位方式
    + 这些属性任何一个都可以被省略        

3. 背景图片与插入图片的区别
    1. 背景图片不占位置，插入图片占位置
    2. 背景图片有定位属性，插入图片没有定位属性
    3. 插入图片比背景图片语义强，所有在企业开发中若需要被搜索引擎搜索，推荐使用插入图片。

4. 精灵图
    1. 精灵图是一种图像合成技术
    2. 此技术将所有图片合成为一张图，从而可以减少请求的次数，降低服务器的压力
    3. css精灵图需要配合背景图片和背景定位来使用

## 9. 边框及盒子
1. 边框属性
   
   + 边框就是环绕在标签宽度和高度周围的线条
   
2. 边框属性的格式
    1. 连写
        1. 同时设置四条边框的属性 
        + border:边框的宽度 边框的样式 边框的颜色
        2. 分别设置四条边框的属性
        + border-top:边框的宽度 边框的样式 边框的颜色
        + border-left:边框的宽度 边框的样式 边框的颜色
        + border-right:边框的宽度 边框的样式 边框的颜色
        + border-bottom:边框的宽度 边框的样式 边框的颜色
            + 这些样色的位置能不能互换，能不能省略，试试就知道
        
    2. 连写(分别设置四条边的边框,方向+样式)
        + border-width:上 右 下 左        
        + border-style:上 右 下 左        
        + border-color:上 右 下 左        

    3. 不连写(方向+样式)
        + border-top-width:
        + border-top-style:
        + border-top-color:

3. 内边距

   + 边框与内容的距离就是内边距

4. 内边距格式
    1. 非连写
        + padding-top:
        + padding-left:
        + padding-right:
        + padding-bottom:
    2. 连写
        + padding:上 右 下 左

5. 外边距

    + 标签与标签之间的距离 margin , 格式同padding
6. 外边距合并

    + 在水平方向上，二者距离会相加，在垂直方向上，距离值不会相加，而是会合并，谁大谁生效


7. 盒子模型
    + 盒子的宽度和高度
        1. 内容的宽度和高度
        就是通过width和height属性设置的宽度和高度
        
        2. 元素的宽度和高度
        宽度 = 左边框 + 左内边距 + width + 右内边距 + 右边框
        高度同理
        
        3. 元素空间的宽度和高度
        宽度 = 左外边距 + 左边框 + 左内边距 + width + 右内边距 + 右边框 + 右外边距 
        + 2和3我认为不对

    + box-sizing属性：可以让盒子元素的宽度和高度保持不变
        1. content-box 元素的宽高 = 边框 + 内边距 + 内容宽高   这个是默认取值
        2. border-box 元素的宽高 = width
    
    + 盒子嵌套关系
        + 如果两个盒子是嵌套关系，那么设置了里面一个盒子顶部的外边距，外面一个盒子也会被顶下来
        + 如果外面的盒子不想被顶下来，可以给外面的盒子添加一个边框属性。
        + 在实际开发中，若需要控制嵌套关系盒子之间的距离，首先考虑padding，其次考虑margin，因为margin本质上是用于控制兄弟关系之间的间隙的，而padding则是用来控制父子之间的距离。
    + 嵌套水平居中
        + 嵌套关系的盒子中，我们可以利用 `margin:0 auto;` 的方式让里面的盒子在外面的盒子中水平居中
        + `margin: 0 auto;` 只对水平方向有效，对垂直方向无效。

    + 内容居中和盒子居中
        1. text-align:center 和 margin:0 auto; 的区别
            + text-align:center     设置盒子中存储的问题/图片水平居中
            + margin:0 auto     让盒子自己水平居中 

8. 行高与字号
    + line-height
        1. 在css中所有的行都有自己的行高
        2. 文字在行高中默认是垂直居中的
        3. 在企业开发中我们经常将行高设置为盒子的高度，这样就能保证一行文字在盒子中是垂直居中的。
        4. 如果在一个盒子中有多行文字，那么我们就不能使用设置行高等于盒子高度来实现让文字垂直居中，只能通过设置padding来让文字居中。
            + 若盒子中存储的是文字，则一般我们以盒子左边的内边距为基准。
            + 顶部的内边距并不是边框到文字顶部的距离，而是边框到行高顶部的距离

## 10. 浮动
1. 网页布局方式
   
    + 网页的布局方式指浏览器是如何对页面中的元素进行排版的
2. 标准流(文档流/普通流)排版方式
    1. 浏览器默认的排版方式就是标准流的排版方式
    2. 在标准流中有两种排版方式
        + 垂直排版----块级元素
        + 水平排版----行内元素、行内块级元素
3. 浮动流排版方式
    + 浮动是一种“半脱离标准流”的排版方式，浮动流只有一种排版方式，就是水平排版，它只能设置某个元素左对齐或者右对齐
    1. 浮动流中没有居中对齐
    2. 在浮动流中不可以使用margin: 0 auto;
    3. 在浮动流中不区分块级、行内、行内块级，他们都能水平排版
    4. 在浮动流中无论是块级元素、行内元素、还是行内块级元素都可以设置宽高
    5.综上，浮动流中的元素和标准流中的行内块级元素很像
4. 浮动元素的脱标
   
    + 若前面一个元素浮动，后面一个元素没有浮动，那么这个时候前面的一个元素就会盖住后面的元素。
5. 浮动元素的排序规则
    1. 相同方向上的浮动元素，先浮动的元素会显示在前面，后浮动的元素会显示在后面
    2. 不同方向上的浮动元素，左浮动会找左浮动，右浮动会找右浮动
    3. 浮动元素浮动之后的位置，由浮动元素浮动之前在标准流中的位置来确定(与水平基线相关)
6. 浮动元素的贴靠现象
   
    + 当宽度不够时，该浮动元素会逐级找他的前面元素进行贴靠
7. 浮动元素字围
   
    + 浮动元素会盖住没有浮动的元素，但不会盖住文字内容，文字内容会围绕浮动元素进行排版，可以用来进行图文混排。
8. 实际开发中，垂直方式向上使用标准流、水平方向上使用浮动流进行排版

## 11. 清除浮动
+ 在标准流中内容的高度可以撑起父元素的高度

+ 在浮动流中浮动的元素是不可以撑起父元素的高度的

1. 清除浮动方式一
    + 给前面一个父元素设置高度
    + 在企业开发中，我们能不写高度就不写高度，所以这种方式很少使用

2. 清除浮动方式二

    + 给后面盒子添加clear属性

      + clear

        + none: 默认取值，按照浮动元素的排序规则来排序(左浮动找左浮动，右浮动找右浮动)

        + left: 不要找前面的左浮动元素

        + right: 不要找前面的右浮动元素

        + both: 不要找前面的左浮动元素和右浮动元素   (最常用)

      + 此法会使得后面盒子不能使用margin-top属性，由于其前面盒子中的元素浮动，导致其前面几乎没有标准流元素，所以margin-top属性会相对于父元素margin-top，而此时父元素为body，所以没有效果    

3. 清除浮动方式三
    1. 外墙法
        1. 在两个盒子中间添加一个额外的块级元素
        2. 在这个额外添加的块级元素设置 clear:both; 属性
            +  外墙法可以让第二个盒子使用margin-top属性，但不可以让第一盒子使用margin-bottom属性
    2. 内墙法  
        1. 在第一个盒子中所有子元素最后添加一个额外的块级元素
        2. 在这个额外添加的块级元素设置 clear:both; 属性
            + 可以让第二个元素使用margin-top，也可以让第一个元素使用margin-bottom
    3. 二者区别
    外墙法不能撑起第一个盒子的高度，而内墙法可以撑起第一个盒子的高度

    4. 上面的两种隔墙法在实际开发中不常用。

4. 清除浮动方式四（推荐）
    + 伪元素选择器
    伪元素选择器作用就是给指定标签的内容前面添加一个子元素或者给指定标签的后面的内容添加一个子元素
    + 格式
        + 标签名称::before{属性:值;...}
        + 标签名称::after{属性:值;...}
5. 使用伪元素选择器按类似方式三的方法添加内墙
    + ```css
      .clearFloat::after{
          content:'';
          display:block;
          clear:both;
          height:0; // 需要这行吗，需要
          visibility:hidden; // 需要这行吗
      }
      // 对于ie6，需要添加下面代码进行兼容
      .box{
          *zoom:1;
      }
      ```

6. 清除浮动方式五 (最推荐)
    + 使用overflow属性
        1. 可以将超出标签范围的内容裁剪掉
        2. 清除浮动
        3. 可以通过overflow:hidden; 让里面的盒子设置margin-top之后，外面的盒子不被顶下来。(使用overflow可以不用给外面盒子设置边框)

7. 使用css clear清除浮动
    ```html
    <body>
    <div>
        <div class="left-float"></div>
        <div class="right-float"></div>
        <div style="clear: both"></div>  <!-- 在父级</div>前加带clear对象的盒子 -->
    </div>
    </body>
    ```

## 12. 定位流
1. 相对定位
    + 相对定位就是相对于原来自己以前在标准流中的位置来移动
    ```$xslt
        position:relative;
        top: xxpx;
        left: xxpx;
        bottom: 0px;
        right: 0px;
    ```
2. 特点
    1. 相对定位是不脱离标准流的，会继续在标准流中占用一份空间
    2. 在相对定位中同一个方向上的定位属性只能使用一个
    3. 由于相对定位是不脱离标准流的，所以在相对定位中是区分块级元素、行内元素和行内块级元素的
    4. 由于相对定位是不脱离标准流的，并且相对定位的元素会占用标准流中的位置，所以当给相对定位的元素设置margin/padding等属性时会影响到标准流中的布局
3. 应用
    1. 用于对元素进行微调
    2. 配合后面学习的绝对定位来使用

4. 绝对定位
    + 绝对定位是相对body来定位的
    + 特点 
        1. 绝对定位的元素时脱离标准流的
        2. 绝对定位的元素是不区分块级元素、行内元素和行内块级元素的，都可以设置宽高
    + 参照点
        1. 默认情况下所有的绝对定位的元素，无论有没有祖先元素，都会以body作为参考点
        2. 若一个绝对定位元素有祖先元素，且祖先元素也是定位流，那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点
            + 只要是这个绝对定位的祖先元素都可以
            + 指的定位流是指绝对定位/相对定位/固定定位
            + 定位流中只有静态定位不行
    + 若一个绝对定位的元素有祖先元素，并且祖先元素也是定位流，而且祖先元素中有多个元素都是定位流，那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点

    + 注意点
        1. 若一个绝对定位的元素以body作为参考点，那么其实是网页首屏的宽度和高度作为参考点，而不是以整个网页的宽高作为参考点
        2. 一个绝对定位的元素的会忽略祖先元素的padding  (都脱离标准流了当然没祖先元素padding啥)
    + 绝对定位弊端
        + 默认情况下绝对定位的元素会以body作为参考点，所以会随着浏览器的高度宽度的变化而变化
        + 在实际开发中都会用子元素用绝对定位，父元素用相对定位。(子绝父相)
   
5. 固定定位
    + 背景定位可以让背景图片不随着滚动条的滚动而滚动，而固定定位可以让某个盒子不随着滚动条的滚动而滚动
    + 注意点
        1. 固定定位的元素是脱离标准流的，不会占用标准流中的空间
        2. 固定定位和绝对定位一样不区分行内/块级/行内块级
6. z-index属性
    + 默认情况下所有的元素都有一个默认的z-index属性，取值是0，z-index属性的作用是专门用于控制定位流元素的覆盖关系
    1. 默认情况下定位流中的元素会盖住标准流中的元素
    2. 默认情况下定位流中元素后面编写的会盖住前面编写的
    3. 若设置了z-index属性，谁的z-index值大，谁就会显示在上面
        + 从父现象
            + 若两个元素的父元素都没有设置z-index属性，那么谁的z-index属性比较大谁就显示在上面
            + 若两个元素的父元素都设置了z-index属性，那么子元素的z-index属性就会失效，也就是说谁的父元素的z-index属性比较大谁就会显示在上面

## 13. a标签伪类选择器
+ a标签存在一些状态
    1. 默认状态，从未被访问过
    2. 被访问过的状态
    3. 鼠标长按的状态
    4. 鼠标悬停在标签的状态
+ a标签的伪类选择器就是专门用来修饰a标签不同状态样式的
+ 格式
    1. :link    修改从未被访问过状态下的样式
    2. :visited     修改被访问过的状态
    3. :active     修改长按时的状态
    4. :hover      修改悬停时的样式
+ 注意点
    1. a标签的伪类选择器可以单独出现也可以同时出现
    2. a标签的伪类选择器若一起出现，那么有严格的顺序要求: 爱恨原则 love hate  l link v visited h hover a active
    3. 若默认状态的样式和被访问过的状态样式一样，那么可以缩写

## 14. 过渡模块
+ 过渡三要素
    1. 必须要有属性发生变化
    2. 必须告诉系统哪个属性需要执行过渡效果  transition-property
    3. 必须告诉系统过渡效果持续时长   transition-duration
        + http://www.w3school.com.cn/css3/css3_transition.asp

+ 当多个属性需要同时执行过渡效果时用逗号分隔开即可

+ 连写格式
    1. transition: 过渡属性 过渡时长 运动速度 延迟时间
    2. 过渡连写注意点
        + 和分开写一样, 如果想给多个属性添加过渡效果也是用逗号隔开即可
        + 连写的时可以省略后面的两个参数, 因为只要编写了前面的两个参数就已经满足了过渡的三要素
        + 如果多个属性运动的速度/延迟的时间/持续时间都一样, 那么可以简写为 transition:all 0s;
    
+ 编写套路
    1. 首先不要管过渡，先编写基本界面
    2. 修改我们认为需要修改的属性
    3. 最后回过头去给被修改属性的那个元素添加过渡即可 

##　15. 2D转换
+ 属性
    + http://www.w3school.com.cn/css3/css3_2dtransform.asp
+ 形变中心
+ 旋转轴向
+ 透视属性 perspective
+ 阴影
    1. box-shadow: 水平偏移 垂直偏移 模糊度 阴影扩展 阴影颜色 内外阴影;
    2. 盒子的阴影分为内外阴影，默认情况下就是外阴影
    3. 快速添加阴影只需要编写三个参数即可
        + box-shadow: 水平偏移 垂直偏移 模糊度;
        + 默认情况下阴影的颜色和盒子内容的颜色一致
    4. 文字阴影
        + text-shadow: 水平偏移 垂直偏移 模糊度 阴影颜色; 

## 16. 常用字体图标库
+ https://www.iconfont.cn
+ https://icomoon.io
+ 字体图标使用
    1.设计师提供svg格式图标
    2.上传到对应字体图标网站
    3.下载生成的代码使用

## 17. 清除默认边距 (外边距和内边距)
+ 为什么要清除
  
+ 在企业开发中为了更好的控制盒子的宽度和高度，以及计算盒子的宽高，编写代码之前第一件事情就是清空默认的边距。
  
+ 如何清除
    1. 通配符选择器会遍历当亲啊界面的所有元素，性能低
         ```
         * {
             margin: 0;
             padding: 0;
          }
         ```
    
    2. 使用如下这段代码
        ```
        body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0}
        ```
       网址: 
       + https://yuilibrary.com/yui/docs/cssreset/
       + http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css


## 18. 背景相关属性

1. 背景尺寸相关属性

   + background-size
     + 不设置值会使用图片默认尺寸
     + cover : 想象背景图片等比拉伸直至图片覆盖这个元素，即宽度和高度都覆盖这个元素
     + contain ：想象背景图片等比拉伸直至图片的某一边碰到元素，即高度或宽度覆盖元素

2. 背景图片定位属性

   + background-origin 背景图片从什么位置开始显示
     + padding-box 默认值
     + border-box
     + content-box

3. 背景绘制区域属性

   + background-clip : 用来指定从哪个位置开始绘制背景
     + padding-box
     + border-box : 默认值
     + content-box

4. 多重背景图片

   + 多张图片用逗号隔开

     ```css
     .box{
         background:url("1.png"),url(2.png);
     }
     ```

## 19. 边框相关属性

1. border-radius:左上角 右上角 右下角 左下角
2. border-radius:50%  将正方形变为圆形
3. 注意点
   + 当边框圆角 > 边框宽度的时候，外边框和内边框都会变成圆角 ----利用这个特性可以实心环
   + 当边框圆角 <= 外边框宽度的时候，外边框是圆角，内边框依然是直角
4. 可以通过border-xxx-xx-radius的方式单独设置某一个角的值
   + border-xxx-xx-radius接收两个参数, 第一个表示水平方向, 第二个表示垂直方向
   + border-xxx-xx-radius如果只传递了一个参数, 那么出自方向和水平方向的值一样
5. 绘制椭圆
   + 绘制椭圆设置水平方向为宽度的一半, 设置垂直方向为高度的一半
6. 边框图片
   + border-image-source: url("images/border.jpg");
   + border-image-slice 对原始图片进行切割然后放到对应边框中
   + border-image-repeat 边框除四个角外如何填充
   + border-image-outset
   + 简写 border-image: 资源地址 切割方式 填充模式;

## 20. 渐变

+ 渐变 = 方向 + 端点颜色
+ 线性渐变
  + background:linear-gradient(45deg,red,green); //至少两个颜色，没有上限
  + 方向可以使用to top...，也可使用使用deg角度，当使用角度时，0deg是从下往上，角度变化是顺时针方向
  + 除了系统自动计算渐变范围外，我们也可以手动指定渐变范围
    + background: linear-gradient(to right, red 100px, green 200px, blue 300px);
+ 径向渐变
  + background: radial-gradient(100px at 200px 100px ,red, green);

## 21. 伸缩布局

1. 属性
   + display: flex
   + flex-direction : 修改主轴起点 （注意先按照主轴排版，再按对齐方式对齐）
     + row 默认值
     + row-reverse
     + column
     + column-reverse
   + justify-content: 主轴方向上伸缩项对齐方式
     + flex-start 默认值
     + flex-end
     + center
     + space-between
     + space-around
   + align-items: 在侧轴上对齐
     + flex-start
     + flex-end
     + center
     + baseline : 让所有伸缩项中的基线在一条直线上对齐
     + stretch : 拉伸对齐 (若设置了这个属性，则给伸缩项设置的高度无效) 
   + align-self : 控制单个伸缩性在侧轴上对齐，取值与align-items一致
   + 换行：当伸缩容器一行容不下所有伸缩项时，默认会自动等比压缩所有伸缩项
     + flex-wrap 
       + nowrap : 默认值，不换行
       + wrap :
       + wrap-reverse
     + align-content 专门用于设置换行之后的对齐方式，只有伸缩项换行后，此属性才生效
       + flex-start
       + flex-end
       + center
       + space-between
       + space-around
       + stretch ： 默认值
   + order 用在伸缩项中进行排序，默认值为0，值越大越往后，可以取负值
   + flex-grow：伸缩项扩充属性，默认值0，表示我们设置的宽度是多少就按照多少来显示, 不进行任何的扩充
     + 只有当所有伸缩项的宽度总和小于伸缩容器宽度的时候flex-grow这个属性才有效
   + flex-shrink : 伸缩项缩小，默认情况下flex-shrink的取值是1, 表示当所有伸缩项宽度的总和大于伸缩容器宽度的时候等比缩小自己
     +  只有当所有伸缩项的宽度总和大于伸缩容器宽度的时候flex-shrink这个属性才有效
   + 伸缩扩充和缩小注意点
     + 如果没有指定flex-grow属性, 或者flex-grow:的值是0, 那么当前的伸缩项不会被扩充
     + 如果flex-shrink的值是0, 那么当前的伸缩项不会被缩小
     + 前面所写的注释都是说宽度扩充或者宽度缩小, 但是这种说法是不严谨的，也有可能扩充和缩小的是高度, 到底是宽度还是高度是由主轴决定的, 扩充和缩小的是主轴方向上的值
   + flex-basis
     + 这个属性可以设置伸缩项的宽度，这个只有在伸缩布局中才有效
     + flex-basis的优先级高于元素的width，前提是二者皆设置了具体的值
     + 若flex-basis设置为auto，而width设置了具体值，则width生效，谁具体，谁生效，二者一样，flex-basis厉害
   + flex连写
     + flex: 扩充 缩小 宽度
     + flex: 0 1 auto;  默认值
2. 主轴和侧轴永远正交



## 22. 其他

1. 设置网页图标 

   + ico图标生成，若没有ico图标，可以将图片上传到专门生成ico图标的网站

   + ico图标放到站点根目录下

   + ```html
     <link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/>
     ```

2. 优化网站三大标签

   + title
     + 第一重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点
     + 标题长度：Google35个中文，baidu28个中文
     + 格式：网站名（产品名）- 网站的介绍
     + 特点：越先出现的词语，权重越高
   + Keywords
     + 页面关键词，搜索引擎重点关注点之一
     + Keywords应该限制在6~8个，电商类可以多几个
   + Description
     + 比关键词作用低，但任很重要，简明扼要说明网站做什么
     + 补充在title和keywords中未能充分表述的说明
     + 字符数含空格在内不要超过120个汉字
     + 描述中出现关键词，与正文内容相关，要写的详细，让人感兴趣

3. 导入CSS Rest类库，将所有浏览器自带样式去除，保持各个浏览器渲染一致性

   + reset.css
     + 无论是否有用，一律清零
   + normalize.css
     + 保护有用的浏览器默认样式而不是完全去除他们
     + 修复浏览器自身的bug并保证各浏览器的一致性

4. 设置全局通用字体行高，一般写在body里

   + ```css
     body{
         font: 12px/1.5em "Microsoft Yahei,arial";
         color:#999;
         background:#f2f2f2;
     }
     ```

   + 

5. 优雅降级 和 渐进增强

   + 优雅降级
     + 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能，达到更好的用户体验
   + 渐进增强
     + 一开始就在高级浏览器上构建完整的功能，然后再针对低版本浏览器进行兼容
   + 建议：目前没有必要再考虑低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器兼容问题。
     + 修补时目前最常见的做法是为低版本浏览器单独制作一个跳转页面
