# 一、图解HTTP

## 1. 基础

1. TCP/IP协议族分层管理
   + 应用层
     + http、ftp、dns
   + 传输层
     + tcp
       + 三次握手机制提供可靠的传输
     + udp
   + 网络层
     + ip
   + 链路层
2. http协议
   + 用于客户端和服务端通信
   + 请求报文
     1. 报文首部
        + 请求行：包含请求方法，请求uri和http版本
        + 请求头
     2. 空行
     3. 报文主体
        + 请求体
   + 响应报文
     1. 报文首部
        + 状态行：响应结果状态码，原因短语和http版本
        + 响应头
     2. 空行
     3. 报文主体
        + 响应体
   + http协议是无状态协议，为了实现状态管理，引入了cookie和session
     + cookie通过在请求和响应报文中写入cookie信息来控制客户端的状态
     + cookie交互流程
       1. 客户端首次请求服务端，请求头没有cookie信息
       2. 服务端生成cookie信息并在响应头中添加set-cookie属性，cookie内容有sessionID，路径，过期时间
       3. 客户端接收响应并根据set-cookie对cookie信息进行保存
       4. 客户端再次请求服务端，请求头部会自动携带cookie信息
   + http方法
     1. **get** ：获取资源
     2. **post**：传输实体主体
     3. **put**：传输文件
     4. **head**：获得报文首部
     5. **delete**：删除文件
     6. options：询问支持的方法
     7. trace：追踪路径
     8. connect：要求用隧道协议连接代理
   + 通过keep-alive属性实现持久连接

## 2. HTTP状态码

1. 状态码类别

   + 1xx : 信息性状态码--接收的请求正在处理
   + 2xx：成功状态码--请求正常处理完毕
   + 3xx：重定向状态码--需要进行附加操作以完成请求
   + 4xx：客户端错误状态码--服务器无法处理请求
   + 5xx：服务器错误状态码--服务器处理请求出错

2. 常见14种状态码

   1. 2xx
      + **200** ok ：客户端发送的请求在服务端被正常处理了
      + **204** No Content：服务端接收请求并正常处理，但没有内容可以返回
      + 206 Partial Content：客户端发送了范围请求，并且服务端成功处理了这部分请求
   2. 3xx
      + **301** Moved Permanently：永久重定向
      + **302** Found：临时重定向
      + 303
      + **304** Not Modified：客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况（例如发送一份请求说给我一份修改后的资源，返回结果说没有修改后资源）
      + 307
   3. 4xx
      + **400** Bad Request：请求报文存在语法错误，服务器理解不了报文信息
      + **401** Unauthorized：发送的请求需要通过http认证
      + **403** Forbidden：对请求资源的访问被服务器拒绝了，拒绝的原因有未获得文件授权，访问权限出现某些问题
      + **404** Not Found：在服务器上找不到请求的资源
   4. 5xx
      + **500** Internal Server Error：服务端在处理请求时出现错误，一般是web服务代码有问题
      + **503** Service Unavailable：服务不可用，服务器可能暂时处于超负载运行或正停机维护，现在无法处理请求

## 3. 数据转发

   1. 代理
      + 代理不改变请求uri，只做请求的转发
      + 代理的用处
        1. 缓存代理，加快资源访问速度
        2. 转发请求或响应
           + 透明代理：不对报文做任何修改
           + 非透明代理：会对报文做修改
   2. 网关
      + 和代理类似，但网关能进行非http协议通信
   3. 隧道

## 4. HTTP常用头部

1. 通用头部
   + Cache-Control：控制缓存行为
   + Connection
     + 作用：
       1. 控制不再转发给代理的首部字段  
       2. 管理持久连接，http1.1默认连接是keep-alive持久连接，当服务器想断开连接时会指定值为close
   + Date：创建报文日期和时间
   + Upgrade
2. 请求头部
   + Accept：告知服务器客户端能够处理的文件类型
   + Accept-Charset：告知服务器客户端支持的字符集
   + Accept-Encoding：告知服务器客户端支持的压缩编码，常见有gzip
   + Accept-Language：告知服务器客户端支持的自然语言
   + Authorization
   + Host：主机名
   + 附带条件请求
     + 形如If-xx，例如If-Match，服务器接收到此类条件请求时，只有判断条件为真时，才会执行请求
     + If-Match ----> ETag ：二者值一致时服务器才会接受请求，否则返回412
     + If-Modified-Since
       + 告知服务器如果字段值早于资源的更新时间，则希望能处理该请求，服务器接收到请求后判断条件为真，则正常处理，否则返回304
       + 这个字段可用于确认代理或客户端拥有的本地资源的有效性
   + Referer：告知服务器请求的原始资源的URI
   + User-Agent：告知服务器客户端的类别
   + Cookie：告知服务器可以通过此Cookie获取用户状态
3. 响应头部
   + Age：告知客户端源服务器在多久前创建了响应，单位为秒
   + ETag：告知客户端实体标识，用字符串为资源做唯一标识，服务器会为每一份资源分配对应的ETag，当资源更新时，ETag值会变化
     + ETag值有强弱之分
   + Location：引导客户端去此URI获取资源，通常配合重定向使用
   + Retry-After：告知客户端多长时间后再次发送请求，单位为秒，常配合503或重定向使用
   + Server：告知客户端服务器应用程序信息
   + Vary：可对缓存进行控制？
   + Set-Cookie：告知客户端要存储Cookie信息
     + name=value：必填，赋予Cookie名称和值
     + expires=date：Cookie有效期，若不设置默认为会话结束
     + path=path：设置服务器文件路径
     + domain=域名：设置Cookie适用对象域名
     + Secure：仅在HTTPS时才会发送Cookie
     + HttpOnly：使Cookie不能被JS脚本访问，可以防止跨站脚本攻击（xss，cross-site-scripting）
4. 实体头部
   + Allow：告知客户端服务器支持的Http方法
   + Content-Encoding：告知客户端实体内容压缩编码方式
   + Content-Language：告知客户端实体使用的自然语言
   + Content-Length：告知客户端实体内容大小，单位为字节
   + Content-Location
   + Content-MD5：报文主体的MD5值
   + Content-Type：说明主体内容媒体类型
   + Expires：告知客户端资源失效日期，当与Cache-Control同时出现时，以Cache-Control为准
   + Last-Modified：资源最后修改时间
5. 其他头部
   + X-Frame-Options：防止点击劫持攻击
   + X-XSS-Protection：防止跨站脚本攻击
   + DNT：拒绝追踪
   + P3P

## 5. HTTPS

1. HTTP缺点
   + 数据明文传输没有加密，内容可被窃听
   + 不需要验证通信方身份，可能遭遇伪装
   + 无法证明报文完整性，内容可能已被篡改
2. 加密方式
   + 通信加密：HTTPS
   + 内容加密：加密算法
3. HTTPS：提供加密 + 认证 + 内容摘要
   + 加密：采用共享密钥加密和公开密钥加密的混合加密机制，在交换共享密钥环节使用公开密钥加密方式，之后建立通信传输报文阶段使用共享密钥加密方式
   + CA证书证明公钥的可信赖性，浏览器内部有常用认证机构的公钥及证书
   + 内容摘要？？？



## 6. 认证方式

1. Basic认证
2. Digest认证
3. SSL认证
4. **基本表单认证**
   + 基于Cookie来管理会话
     1. 客户端输入账密发送登录认证
     2. 服务器认证身份并生成sessionID，并将认证状态和sessionID绑定记录在服务端，响应客户端时，在响应头部set-cookie字段写入sessionID
     3. 客户端接收到cookie后会保存到本地，在下次请求时自动带上cookie

## 7. 攻击技术

1. 攻击模式
   + 主动攻击
     1. SQL注入
     2. OS命令注入攻击
   + 被动攻击
     1. 跨站脚本攻击
     2. 跨站点请求伪造